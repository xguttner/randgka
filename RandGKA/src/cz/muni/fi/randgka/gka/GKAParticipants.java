package cz.muni.fi.randgka.gka;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import android.util.Log;

/**
 * Class containing a List<GKAParticipant> to provide them to the GKAProtocol,
 *  and functions for their management.
 */
public class GKAParticipants implements Serializable {

	private static final long serialVersionUID = -3730203057969772914L;

	protected List<GKAParticipant> participants;
	
	public GKAParticipants() {
		participants = new ArrayList<GKAParticipant>();
	}
	
	/**
	 * @param id of wanted participant
	 * @return GKAParticipant with given id, or null if it is not present
	 */
	public GKAParticipant getParticipant(int id) {
		if (participants != null) {
			for (GKAParticipant p : participants) {
				if (p.getId() == id) return p;
			}
		}
		return null;
	}
	
	/**
	 * @return size of participants list
	 */
	public int size() {
		return participants.size();
	}
	
	/**
	 * @param gkaParticipant - participant to add
	 */
	public void add(GKAParticipant gkaParticipant) {
		if (participants != null) {
			participants.add(gkaParticipant);
		}
	}
	
	/**
	 * @param address of a GKAParticipant
	 * @return true if GKAParticipant with given address is contained in the list, false otherwise
	 */
	public boolean contains(byte[] address) {
		if (participants != null) {
			for (GKAParticipant p : participants) {
				if (Arrays.equals(address, p.getAddress())) return true;
			}
		}
		return false;
	}
	
	/**
	 * @param id of GKAParticipant to remove from list
	 */
	public void remove(int id) {
		if (participants != null) {
			for (GKAParticipant p : participants) {
				if (p.getId() == id) participants.remove(p);
			}
		}
	}
	
	/**
	 * @return participant relevant to the application's device, null if it is not present
	 */
	public GKAParticipant getMe() {
		for (GKAParticipant p : participants) {
			if (p.isMe()) return p;
		}
		return null;
	}
	
	/**
	 * @return participant with the leader role
	 */
	public GKAParticipant getLeader() {
		for (GKAParticipant p : participants) {
			if (p.getRole().equals(GKAParticipantRole.LEADER)) return p;
		}
		return null;
	}
	
	/**
	 * @return all participants except the one returned by getMe() function
	 */
	public GKAParticipants getAllButMe() {
		GKAParticipants participants2 = new GKAParticipants();
		if (participants != null) {
			for (GKAParticipant p : participants) {
				if (!p.isMe()) participants2.add(p);
			}
		}
		return participants2;
	}
	
	/**
	 * @return ordered byte array of nonces of all participants in the list, null if nonces are not set
	 */
	public byte[] getNonces() {
		if (getLeader() != null && getLeader().getNonceLen() > 0) {
			int nonceLen = getLeader().getNonceLen();
			byte[] noncesArray = new byte[nonceLen*size()];
			int i = 0;
			// sort according to id
			Collections.sort(participants, new Comparator<GKAParticipant>() {
				@Override
				public int compare(GKAParticipant g0, GKAParticipant g1) {
					return g0.getId() - g1.getId();
				}
			});
			for (GKAParticipant p : participants) {
				System.arraycopy(p.getNonce(), 0, noncesArray, i*nonceLen, nonceLen);
				i++;
			}
			return noncesArray;
		} else return null;
	}
	
	public List<GKAParticipant> getParticipants() {
		return participants;
	}

	public void setParticipants(List<GKAParticipant> participants) {
		this.participants = participants;
	}

	/**
	 * @return length of transfer object
	 */
	public int getTOLength() {
		int length = 0;
		if (participants != null) {
			for (GKAParticipant p : participants) {
				length += p.getTOLength();
			}
		}
		return length+1;
	}
	
	/**
	 * @return byte array suitable for transfer over communication channel
	 */
	public byte[] getTransferObject() {
		try {
			ByteArrayOutputStream bStream = new ByteArrayOutputStream();
			// size of the overall set
			bStream.write((byte)participants.size());
			// transfer object of each participant
			for (GKAParticipant p : participants) {
				bStream.write(p.getTransferObject());
			}
			return bStream.toByteArray();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
	
	/**
	 * @param byte array containg the transfer object generated by getTransferObject()
	 */
	public void fromTransferObject(byte[] bytes, int nonceLen) {
		int offset = 1;
		int i = 0;
		// size of participants set
		byte participantsSize = bytes[0];
		byte[] currentParticipantBytes = null;
		while (i < participantsSize) {
			currentParticipantBytes = new byte[bytes.length - offset];
			System.arraycopy(bytes, offset, currentParticipantBytes, 0, bytes.length - offset);
			GKAParticipant p = new GKAParticipant();
			p.setNonceLen(nonceLen);
			p.fromTransferObject(currentParticipantBytes);
			
			if (participants.contains(p)) {
				GKAParticipant pIn = getParticipant(p.getId());
				if (!pIn.isMe()) {
					pIn.setPublicKey(p.getPublicKey());
					pIn.setName(p.getName());
					pIn.setNonce(p.getNonce());
				}
			} else {
				participants.add(p);
			}
			 
			offset += p.getTOLength();
			i++;
		}
	}
	
	/**
	 * Initialize each participant's parameters lengths
	 *  
	 * @param nonceLength
	 * @param publicKeyLength
	 */
	public void initialize(Integer nonceLength, Integer publicKeyLength) {
		if (participants != null) {
			for (GKAParticipant p : participants) {
				p.setNonceLen(nonceLength);
				p.setPkLen(publicKeyLength);
			}
		}
	}
	
}
